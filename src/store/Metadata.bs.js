// Generated by BUCKLESCRIPT VERSION 5.0.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Js_mapperRt = require("bs-platform/lib/js/js_mapperRt.js");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

var jsMapperConstantArray = /* array */[
  /* tuple */[
    -922783157,
    "name"
  ],
  /* tuple */[
    -271659236,
    "email"
  ],
  /* tuple */[
    845320543,
    "required"
  ]
];

function validatorToJs(param) {
  return Js_mapperRt.binarySearch(3, param, jsMapperConstantArray);
}

function validatorFromJs(param) {
  return Js_mapperRt.revSearch(3, jsMapperConstantArray, param);
}

var DecodeTypeException = Caml_exceptions.create("Metadata-ReactHooksTemplate.DecodeTypeException");

function decode(json) {
  return /* record */Block.record([
            "scope",
            "key",
            "title",
            "description"
          ], [
            Json_decode.field("scope", Json_decode.string, json),
            Json_decode.field("key", Json_decode.string, json),
            Json_decode.field("title", Json_decode.string, json),
            Json_decode.optional((function (param) {
                    return Json_decode.field("description", Json_decode.string, param);
                  }), json)
          ]);
}

function decodeMany(json) {
  return Json_decode.array(decode, json);
}

var Vocabulary = /* module */Block.localModule([
    "decode",
    "decodeMany"
  ], [
    decode,
    decodeMany
  ]);

function decode$1(json) {
  var v = Json_decode.field("data_type", Json_decode.string, json);
  var tmp;
  switch (v) {
    case "arraystring" : 
        tmp = /* ArrayString */3;
        break;
    case "boolean" : 
        tmp = /* Boolean */2;
        break;
    case "integer" : 
        tmp = /* Integer */1;
        break;
    case "string" : 
        tmp = /* String */0;
        break;
    default:
      throw [
            DecodeTypeException,
            "Missing type conversion case for field data_type: " + (v + (", JSON: " + JSON.stringify(json)))
          ];
  }
  var __x = Json_decode.optional((function (param) {
          return Json_decode.field("validators", (function (param) {
                        return Json_decode.array(Json_decode.string, param);
                      }), param);
        }), json);
  var __x$1 = Json_decode.optional((function (param) {
          return Json_decode.field("editable", Json_decode.bool, param);
        }), json);
  return /* record */Block.record([
            "resource_name",
            "name",
            "title",
            "description",
            "data_type",
            "display_type",
            "ref_endpoint",
            "validators",
            "editable",
            "vocab_scope",
            "vocabularies"
          ], [
            Json_decode.field("resource_name", Json_decode.string, json),
            Json_decode.field("name", Json_decode.string, json),
            Json_decode.field("title", Json_decode.string, json),
            Json_decode.field("description", Json_decode.string, json),
            tmp,
            Json_decode.field("display_type", Json_decode.string, json),
            Json_decode.optional((function (param) {
                    return Json_decode.field("ref_endpoint", Json_decode.string, param);
                  }), json),
            Belt_Option.map(__x, (function (arrayString) {
                    return Belt_Array.map(arrayString, (function (v) {
                                  return Belt_Option.getExn(validatorFromJs(v));
                                }));
                  })),
            Belt_Option.getWithDefault(__x$1, true),
            Json_decode.optional((function (param) {
                    return Json_decode.field("vocab_scope", Json_decode.string, param);
                  }), json),
            undefined
          ]);
}

function decodeMany$1(json) {
  return Json_decode.array(decode$1, json);
}

var Field = /* module */Block.localModule([
    "decode",
    "decodeMany"
  ], [
    decode$1,
    decodeMany$1
  ]);

function decode$2(json) {
  return /* record */Block.record([
            "id",
            "name",
            "title",
            "description",
            "fields"
          ], [
            Json_decode.field("id", Json_decode.$$int, json),
            Json_decode.field("name", Json_decode.string, json),
            Json_decode.field("title", Json_decode.string, json),
            Json_decode.field("description", Json_decode.string, json),
            []
          ]);
}

function decodeMany$2(json) {
  return Json_decode.array(decode$2, json);
}

function getField(resource, fieldName) {
  var __x = resource[/* fields */4];
  return Belt_Array.getBy(__x, (function (field) {
                return field[/* name */1] === fieldName;
              }));
}

var Resource = /* module */Block.localModule([
    "decode",
    "decodeMany",
    "getField"
  ], [
    decode$2,
    decodeMany$2,
    getField
  ]);

function fieldDecodeOpt(json, schemaField) {
  var match = schemaField[/* data_type */4];
  switch (match) {
    case 0 : 
        var partial_arg = schemaField[/* name */1];
        return Json_decode.optional((function (param) {
                      return Json_decode.field(partial_arg, Json_decode.string, param);
                    }), json);
    case 1 : 
        var partial_arg$1 = schemaField[/* name */1];
        var __x = Json_decode.optional((function (param) {
                return Json_decode.field(partial_arg$1, Json_decode.$$int, param);
              }), json);
        return Belt_Option.map(__x, (function (prim) {
                      return String(prim);
                    }));
    case 2 : 
        var partial_arg$2 = schemaField[/* name */1];
        var __x$1 = Json_decode.optional((function (param) {
                return Json_decode.field(partial_arg$2, Json_decode.bool, param);
              }), json);
        return Belt_Option.map(__x$1, Pervasives.string_of_bool);
    case 3 : 
        var partial_arg$3 = schemaField[/* name */1];
        var __x$2 = Json_decode.optional((function (param) {
                return Json_decode.field(partial_arg$3, (function (param) {
                              return Json_decode.array(Json_decode.string, param);
                            }), param);
              }), json);
        return Belt_Option.map(__x$2, (function (param) {
                      return param.join(",");
                    }));
    
  }
}

function fieldDecoderExn(json, schemaField) {
  var match = schemaField[/* data_type */4];
  switch (match) {
    case 0 : 
        var partial_arg = schemaField[/* name */1];
        var __x = Json_decode.optional((function (param) {
                return Json_decode.field(partial_arg, Json_decode.string, param);
              }), json);
        return Belt_Option.getWithDefault(__x, "-");
    case 1 : 
        var partial_arg$1 = schemaField[/* name */1];
        var opt = Json_decode.optional((function (param) {
                return Json_decode.field(partial_arg$1, Json_decode.$$int, param);
              }), json);
        if (opt !== undefined) {
          return String(opt);
        } else {
          return "-";
        }
    case 2 : 
        var partial_arg$2 = schemaField[/* name */1];
        var __x$1 = Json_decode.optional((function (param) {
                return Json_decode.field(partial_arg$2, Json_decode.bool, param);
              }), json);
        return Pervasives.string_of_bool(Belt_Option.getWithDefault(__x$1, true));
    case 3 : 
        var partial_arg$3 = schemaField[/* name */1];
        var __x$2 = Json_decode.optional((function (param) {
                return Json_decode.field(partial_arg$3, (function (param) {
                              return Json_decode.array(Json_decode.string, param);
                            }), param);
              }), json);
        return Belt_Option.mapWithDefault(__x$2, "-", (function (v) {
                      return v.join(", ");
                    }));
    
  }
}

function fieldDecoder(json, field) {
  try {
    return fieldDecoderExn(json, field);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Js_exn.$$Error) {
      var e = exn[1];
      var match = e.message;
      if (match !== undefined) {
        return "" + (String(field) + (".name: Decode Error: " + (String(match) + "")));
      } else {
        return "" + (String(field) + (".name: An unknown decode error occurred: " + (String(e) + "")));
      }
    } else if (exn[0] === Json_decode.DecodeError) {
      return exn[1];
    } else {
      throw exn;
    }
  }
}

function singleFieldDecode(json, schemaField) {
  var match = schemaField[/* data_type */4];
  switch (match) {
    case 0 : 
        return Json_decode.string(json);
    case 1 : 
        return String(Json_decode.$$int(json));
    case 2 : 
        return Pervasives.string_of_bool(Json_decode.bool(json));
    case 3 : 
        return Json_decode.array(Json_decode.string, json).join(", ");
    
  }
}

function nullDecoder(json) {
  return json;
}

function jsonArrayDecoder(param) {
  return Json_decode.array(nullDecoder, param);
}

var UndefinedEncoder = Caml_exceptions.create("Metadata-ReactHooksTemplate.Encode.UndefinedEncoder");

function encodeField(field, formValue) {
  var match = field[/* data_type */4];
  switch (match) {
    case 0 : 
        return formValue;
    case 1 : 
        return Caml_format.caml_float_of_string(formValue);
    case 2 : 
        return Pervasives.bool_of_string(formValue);
    case 3 : 
        throw [
              UndefinedEncoder,
              "Encoder for \"" + (String(field) + ".name\" is not defined")
            ];
    
  }
}

var Encode = /* module */Block.localModule([
    "UndefinedEncoder",
    "encodeField"
  ], [
    UndefinedEncoder,
    encodeField
  ]);

var debug_mode = false;

exports.debug_mode = debug_mode;
exports.validatorToJs = validatorToJs;
exports.validatorFromJs = validatorFromJs;
exports.DecodeTypeException = DecodeTypeException;
exports.Vocabulary = Vocabulary;
exports.Field = Field;
exports.Resource = Resource;
exports.fieldDecodeOpt = fieldDecodeOpt;
exports.fieldDecoderExn = fieldDecoderExn;
exports.fieldDecoder = fieldDecoder;
exports.singleFieldDecode = singleFieldDecode;
exports.nullDecoder = nullDecoder;
exports.jsonArrayDecoder = jsonArrayDecoder;
exports.Encode = Encode;
/* No side effect */
