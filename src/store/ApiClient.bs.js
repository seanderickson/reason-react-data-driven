// Generated by BUCKLESCRIPT VERSION 5.0.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Fetch = require("bs-fetch/src/Fetch.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Metadata$ReactHooksTemplate = require("./Metadata.bs.js");

var apiUrl = "http://localhost:3000";

function $$fetch$1(url, decoder) {
  return fetch(url).then((function (response) {
                  var status = response.status;
                  var statusText = response.statusText;
                  if (response.ok) {
                    return response.json().then((function (json) {
                                  return Promise.resolve(/* Ok */Block.variant("Ok", 0, [Curry._1(decoder, json)]));
                                }));
                  } else {
                    return Promise.resolve(/* Error */Block.variant("Error", 1, ["Response Error: status=" + (String(status) + (", \"" + (String(statusText) + "\" ")))]));
                  }
                })).catch((function (err) {
                console.log("error", err);
                return Promise.resolve(/* Error */Block.variant("Error", 1, ["API error (URL: " + (String(url) + (", error=" + (String(err) + ")")))]));
              }));
}

function postPatch(url, method_, decoder, payload) {
  console.log("posting: ", url);
  return fetch(url, Fetch.RequestInit[/* make */0](method_, {
                        "Content-Type": "application/json"
                      }, Caml_option.some(JSON.stringify(payload)), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(/* () */0)).then((function (response) {
                  var status = response.status;
                  var statusText = response.statusText;
                  if (response.ok) {
                    console.log("Status ok, decoding json...");
                    return response.json().then((function (json) {
                                  return Promise.resolve(/* Ok */Block.variant("Ok", 0, [Curry._1(decoder, json)]));
                                }));
                  } else {
                    return Promise.resolve(/* Error */Block.variant("Error", 1, ["Response Error: status=" + (String(status) + (", \"" + (String(statusText) + "\" ")))]));
                  }
                })).catch((function (err) {
                console.log("post error", err);
                return Promise.resolve(/* Error */Block.variant("Error", 1, ["API POST error(URL: " + (String(url) + (", error=" + (String(err) + ")")))]));
              }));
}

var BadStatus = Caml_exceptions.create("ApiClient-ReactHooksTemplate.BadStatus");

function getVocabularies(param) {
  return $$fetch$1("http://localhost:3000/vocabulary", Metadata$ReactHooksTemplate.Vocabulary[/* decodeMany */1]);
}

function getFields(param) {
  return $$fetch$1("http://localhost:3000/field", Metadata$ReactHooksTemplate.Field[/* decodeMany */1]);
}

function getResources(param) {
  return $$fetch$1("http://localhost:3000/resource", Metadata$ReactHooksTemplate.Resource[/* decodeMany */1]);
}

function assembleField(field, vocabs) {
  var match = field[/* vocab_scope */9];
  if (match !== undefined) {
    var vocab_scope = match;
    return /* record */Block.record([
              "resource_name",
              "name",
              "title",
              "description",
              "data_type",
              "display_type",
              "ref_endpoint",
              "validators",
              "editable",
              "vocab_scope",
              "vocabularies"
            ], [
              field[/* resource_name */0],
              field[/* name */1],
              field[/* title */2],
              field[/* description */3],
              field[/* data_type */4],
              field[/* display_type */5],
              field[/* ref_endpoint */6],
              field[/* validators */7],
              field[/* editable */8],
              field[/* vocab_scope */9],
              vocabs.filter((function (v) {
                      return v[/* scope */0] === vocab_scope;
                    }))
            ]);
  } else {
    return field;
  }
}

function assembleResources(resources, fields, vocabs) {
  var assembledFields = Belt_Array.map(fields, (function (field) {
          return assembleField(field, vocabs);
        }));
  return Belt_Array.map(resources, (function (resource) {
                return /* record */Block.record([
                          "id",
                          "name",
                          "title",
                          "description",
                          "fields"
                        ], [
                          resource[/* id */0],
                          resource[/* name */1],
                          resource[/* title */2],
                          resource[/* description */3],
                          assembledFields.filter((function (f) {
                                  return f[/* resource_name */0] === resource[/* name */1];
                                }))
                        ]);
              }));
}

function buildResources(param) {
  return getVocabularies(/* () */0).then((function (resultv) {
                if (resultv.tag) {
                  return Promise.resolve(/* Error */Block.variant("Error", 1, ["Vocabulary fetch: " + resultv[0]]));
                } else {
                  var vocabs = resultv[0];
                  return getFields(/* () */0).then((function (result1) {
                                if (result1.tag) {
                                  return Promise.resolve(/* Error */Block.variant("Error", 1, ["Field fetch: " + result1[0]]));
                                } else {
                                  var fields = result1[0];
                                  return getResources(/* () */0).then((function (result) {
                                                if (result.tag) {
                                                  return Promise.resolve(/* Error */Block.variant("Error", 1, ["Resource fetch: " + result[0]]));
                                                } else {
                                                  return Promise.resolve(/* Ok */Block.variant("Ok", 0, [assembleResources(result[0], fields, vocabs)]));
                                                }
                                              }));
                                }
                              }));
                }
              }));
}

function getEntityListing(resourceName) {
  return $$fetch$1(apiUrl + ("/" + resourceName), Metadata$ReactHooksTemplate.jsonArrayDecoder);
}

function getEntity(resourceName, id) {
  return $$fetch$1(apiUrl + ("/" + (resourceName + ("/" + id))), Metadata$ReactHooksTemplate.nullDecoder);
}

function postEntity(resourceName, payload) {
  return postPatch(apiUrl + ("/" + resourceName), /* Post */2, Metadata$ReactHooksTemplate.nullDecoder, payload);
}

function patchEntity(resourceName, id, payload) {
  return postPatch(apiUrl + ("/" + (resourceName + ("/" + id))), /* Patch */8, Metadata$ReactHooksTemplate.nullDecoder, payload);
}

var debug_mode = false;

var test_mock_error_mode = false;

exports.debug_mode = debug_mode;
exports.test_mock_error_mode = test_mock_error_mode;
exports.apiUrl = apiUrl;
exports.$$fetch = $$fetch$1;
exports.postPatch = postPatch;
exports.BadStatus = BadStatus;
exports.getVocabularies = getVocabularies;
exports.getFields = getFields;
exports.getResources = getResources;
exports.assembleField = assembleField;
exports.assembleResources = assembleResources;
exports.buildResources = buildResources;
exports.getEntityListing = getEntityListing;
exports.getEntity = getEntity;
exports.postEntity = postEntity;
exports.patchEntity = patchEntity;
/* No side effect */
